<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>極限アクション 10：隠しクリア版</title>
    <style>
        body { margin: 0; background: #111; font-family: sans-serif; overflow: hidden; touch-action: none; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; }
        #ui { position: absolute; top: 20px; left: 20px; color: #ff4444; font-size: 24px; font-weight: bold; z-index: 10; display: none; pointer-events: none; }
        #startScreen { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.95); color: white; z-index: 20; text-align: center; }
        button { padding: 15px 30px; margin: 8px; font-size: 18px; cursor: pointer; border-radius: 10px; border: none; color: white; font-weight: bold; width: 300px; }
        .easy-btn { background: #28a745; }
        .normal-btn { background: #007bff; }
        .hard-btn { background: #dc3545; box-shadow: 0 0 10px #f00; }
        canvas { background: #87CEEB; max-width: 100%; max-height: 100%; border: 2px solid #555; display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <span id="modeName">MODE</span> | STAGE: <span id="stageNum">1</span>/10<br>
        <small id="lifeUI" style="font-size: 16px; color: #fff;"></small>
    </div>
    
    <div id="startScreen">
        <h1 style="color: #ffaa00; font-size: 32px; margin-bottom: 20px;">極限・初見殺し 10</h1>
        <button class="easy-btn" onclick="startGame('EASY')">EASY (3回リトライ可)</button><br>
        <button class="normal-btn" onclick="startGame('NORMAL')">NORMAL (ミス＝1面へ)</button><br>
        <button class="hard-btn" onclick="startGame('HARD')">HARD (滑る＋1面へ)</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stageNum');
        const modeDisplay = document.getElementById('modeName');
        const lifeDisplay = document.getElementById('lifeUI');
        const startScreen = document.getElementById('startScreen');

        canvas.width = 1200; 
        canvas.height = 600;

        let currentStage = 1;
        let player, keys = {}, objects = [];
        let activeInputs = new Map(); 
        let gameRunning = false;
        let selectedMode = 'NORMAL';
        let deathCount = 0;
        let stage10JumpCount = 0; // Stage 10専用ジャンプカウンター

        function startGame(mode) {
            selectedMode = mode;
            startScreen.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            modeDisplay.innerText = selectedMode;
            canvas.style.background = (selectedMode === 'HARD') ? "#1a0000" : (selectedMode === 'EASY' ? "#e0f7fa" : "#87CEEB");
            gameRunning = true;
            deathCount = 0;
            initStage(1);
            requestAnimationFrame(update);
        }

        function initStage(num) {
            const isHard = (selectedMode === 'HARD');
            const gravity = isHard ? 1.4 : 0.9;
            const jumpPower = isHard ? -22 : -20.0;

            player = { x: 50, y: 500, w: 30, h: 30, vx: 0, vy: 0, speed: 8.5, jump: jumpPower, gravity: gravity, friction: (isHard ? 0.85 : 1.0), onGround: false };
            currentStage = num;
            stageDisplay.innerText = currentStage;
            stage10JumpCount = 0; // カウンターリセット
            
            if (selectedMode === 'EASY') lifeDisplay.innerText = "RETRY: " + (3 - deathCount);
            else lifeDisplay.innerText = "NO MERCY (PERMADEATH)";

            const stages = {
                1: [{x:0,y:550,w:200,h:50,type:'p'}, {x:400,y:450,w:150,h:25,type:'p'}, {x:800,y:350,w:150,h:25,type:'p'}, {x:1100,y:250,w:60,h:20,type:'g'}],
                2: [{x:0,y:550,w:200,h:50,type:'p'}, {x:300,y:450,w:200,h:25,type:'p'}, {x:385,y:370,w:40,h:80,type:'t',hidden:true}, {x:650,y:350,w:200,h:25,type:'p'}, {x:1050,y:250,w:60,h:20,type:'g'}],
                3: [{x:0,y:550,w:150,h:50,type:'p'}, {x:300,y:450,w:100,h:20,type:'p',fall:true}, {x:550,y:350,w:100,h:20,type:'p',fall:true}, {x:800,y:250,w:100,h:20,type:'p',fall:true}, {x:1050,y:150,w:60,h:20,type:'g'}],
                4: [{x:0,y:550,w:200,h:50,type:'p'}, {x:300,y:400,w:500,h:25,type:'p'}, {x:450,y:360,w:40,h:40,type:'t',move:6}, {x:900,y:300,w:150,h:25,type:'p'}, {x:1100,y:250,w:60,h:20,type:'g'}],
                5: [{x:0,y:550,w:200,h:50,type:'p'}, {x:350,y:350,w:100,h:20,type:'p'}, {x:650,y:350,w:100,h:20,type:'p'}, {x:1000,y:350,w:60,h:20,type:'g', warp: 10}],
                6: [{x:0,y:550,w:300,h:50,type:'p'}, {x:350,y:500,w:40,h:40,type:'t'}, {x:500,y:400,w:150,h:20,type:'p'}, {x:800,y:300,w:150,h:20,type:'p'}, {x:1100,y:200,w:60,h:20,type:'g'}],
                7: [{x:0,y:550,w:200,h:50,type:'p'}, {x:300,y:450,w:60,h:20,type:'p',fall:true}, {x:550,y:350,w:60,h:20,type:'p',fall:true}, {x:800,y:250,w:60,h:20,type:'p',fall:true}, {x:1100,y:150,w:60,h:20,type:'g'}],
                8: [{x:0,y:550,w:200,h:50,type:'p'}, {x:300,y:250,w:600,h:20,type:'p'}, {x:500,y:210,w:40,h:40,type:'t',move:10}, {x:1050,y:200,w:60,h:20,type:'g'}],
                9: [{x:0,y:550,w:200,h:50,type:'p'}, {x:350,y:450,w:40,h:40,type:'t',hidden:true}, {x:650,y:350,w:40,h:40,type:'t',hidden:true}, {x:900,y:250,w:100,h:20,type:'p'}, {x:1100,y:150,w:60,h:20,type:'g'}],
                // STAGE 10: 物理的にゴール不可能な配置。ゴール(g)をわざと置かない
                10:[{x:0,y:550,w:150,h:50,type:'p'}, {x:600,y:300,w:30,h:10,type:'p'}] 
            };

            objects = (stages[num] || stages[1]).map(obj => ({ ...obj, falling: false }));
        }

        function die() {
            if (selectedMode === 'EASY') {
                deathCount++;
                if (deathCount >= 3) { deathCount = 0; initStage(1); }
                else initStage(currentStage);
            } else { deathCount = 0; initStage(1); }
        }

        function jump() {
            if (player.onGround) {
                player.vy = player.jump;
                player.onGround = false;
                if (currentStage === 10) stage10JumpCount++;
            }
        }

        function update() {
            if (!gameRunning) return;
            let moveX = 0;
            const w = window.innerWidth, h = window.innerHeight;

            activeInputs.forEach((pos) => {
                if (pos.y < h * 0.45) jump();
                if (pos.x < w * 0.4) moveX = -player.speed;
                else if (pos.x > w * 0.6) moveX = player.speed;
            });

            if (keys['ArrowLeft']) moveX = -player.speed;
            if (keys['ArrowRight']) moveX = player.speed;
            if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) jump();

            if (selectedMode === 'HARD') player.vx = player.vx * player.friction + moveX * (1 - player.friction);
            else player.vx = moveX;

            player.vy += player.gravity;
            player.x += player.vx;
            checkCollision('x');
            player.y += player.vy;
            player.onGround = false;
            checkCollision('y');

            // --- STAGE 10 クリア判定 ---
            if (currentStage === 10 && stage10JumpCount >= 3 && player.x < -player.w) {
                alert('SECRET CLEAR! おめでとう！');
                initStage(1);
            }

            objects.forEach(obj => {
                if (obj.hidden) {
                    let d = Math.sqrt(Math.pow(player.x - obj.x, 2) + Math.pow(player.y - obj.y, 2));
                    if (d < 150) obj.hidden = false;
                }
                if (obj.move) { obj.x += obj.move; if (obj.x > 800 || obj.x < 300) obj.move *= -1; }
                if (obj.falling) obj.y += 12;
            });

            if (player.y > canvas.height) die();
            draw();
            requestAnimationFrame(update);
        }

        function checkCollision(axis) {
            objects.forEach(obj => {
                if (obj.hidden) return;
                if (player.x < obj.x + obj.w && player.x + player.w > obj.x &&
                    player.y < obj.y + obj.h && player.y + player.h > obj.y) {
                    if (obj.type === 't') die();
                    if (obj.type === 'g') {
                        deathCount = 0;
                        if (obj.warp) initStage(obj.warp);
                        else if (currentStage >= 10) { alert('PERFECT CLEAR!'); initStage(1); }
                        else initStage(currentStage + 1);
                    }
                    if (obj.type === 'p') {
                        if (obj.fall) obj.falling = true;
                        if (axis === 'x') {
                            if (player.vx > 0) player.x = obj.x - player.w;
                            else if (player.vx < 0) player.x = obj.x + player.w;
                            player.vx = 0;
                        } else {
                            if (player.vy > 0) { player.y = obj.y - player.h; player.vy = 0; player.onGround = true; }
                            else if (player.vy < 0) { player.y = obj.y + obj.h; player.vy = 0; }
                        }
                    }
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            objects.forEach(obj => {
                if (obj.hidden) return;
                ctx.fillStyle = obj.type === 'p' ? (obj.fall ? '#444' : '#222') : (obj.type === 't' ? '#f00' : '#ff0');
                if (obj.type === 't') {
                    ctx.beginPath(); ctx.moveTo(obj.x, obj.y + obj.h); ctx.lineTo(obj.x + obj.w / 2, obj.y); ctx.lineTo(obj.x + obj.w, obj.y + obj.h); ctx.fill();
                } else { ctx.fillRect(obj.x, obj.y, obj.w, obj.h); }
            });
            ctx.fillStyle = (selectedMode === 'HARD') ? '#f55' : (selectedMode === 'EASY' ? '#28a745' : '#07f');
            ctx.fillRect(player.x, player.y, player.w, player.h);

            // Stage 10 用ヒント（開発時確認用。不要なら消してください）
            if (currentStage === 10 && stage10JumpCount >= 3) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                ctx.font = "16px sans-serif";
                ctx.fillText("<< EXIT", 10, 530);
            }
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('touchstart', e => { if (!gameRunning) return; e.preventDefault(); for (let t of e.changedTouches) activeInputs.set(t.identifier, { x: t.clientX, y: t.clientY }); }, {passive: false});
        window.addEventListener('touchmove', e => { if (!gameRunning) return; for (let t of e.changedTouches) if (activeInputs.has(t.identifier)) activeInputs.set(t.identifier, { x: t.clientX, y: t.clientY }); });
        window.addEventListener('touchend', e => { for (let t of e.changedTouches) activeInputs.delete(t.identifier); });
        window.addEventListener('mousedown', e => { if (!gameRunning || e.button !== 0) return; activeInputs.set('mouse', { x: e.clientX, y: e.clientY }); });
        window.addEventListener('mousemove', e => { if (activeInputs.has('mouse')) activeInputs.set('mouse', { x: e.clientX, y: e.clientY }); });
        window.addEventListener('mouseup', () => activeInputs.delete('mouse'));
    </script>
</body>
</html>
