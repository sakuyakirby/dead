<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>極限アクション 10：HARD専用ステージ実装</title>
    <style>
        body { margin: 0; background: #111; font-family: sans-serif; overflow: hidden; touch-action: none; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; }
        #ui { position: absolute; top: 20px; left: 20px; color: #ff4444; font-size: 24px; font-weight: bold; z-index: 10; display: none; pointer-events: none; }
        #startScreen { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.95); color: white; z-index: 20; text-align: center; }
        button { padding: 15px 30px; margin: 8px; font-size: 18px; cursor: pointer; border-radius: 10px; border: none; color: white; font-weight: bold; width: 300px; transition: 0.2s; }
        button:active { transform: scale(0.95); }
        .easy-btn { background: #28a745; }
        .normal-btn { background: #007bff; }
        .hard-btn { background: #dc3545; box-shadow: 0 0 15px #f00; }
        canvas { background: #87CEEB; max-width: 100%; max-height: 100%; border: 2px solid #555; display: none; }
    </style>
</head>
<body>
    <div id="ui">
        <span id="modeName">MODE</span> | STAGE: <span id="stageNum">1</span>/10<br>
        <small id="lifeUI" style="font-size: 16px; color: #fff;"></small>
    </div>
    
    <div id="startScreen">
        <h1 style="color: #ffaa00; font-size: 32px; margin-bottom: 20px;">極限・初見殺し 10</h1>
        <button class="easy-btn" onclick="startGame('EASY')">EASY (3リトライ)</button><br>
        <button class="normal-btn" onclick="startGame('NORMAL')">NORMAL (即1面)</button><br>
        <button class="hard-btn" onclick="startGame('HARD')">HARD (専用ステージ+即1面)</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stageNum');
        const modeDisplay = document.getElementById('modeName');
        const lifeDisplay = document.getElementById('lifeUI');
        const startScreen = document.getElementById('startScreen');

        canvas.width = 1200; 
        canvas.height = 600;

        let currentStage = 1;
        let player, keys = {}, objects = [];
        let activeInputs = new Map(); 
        let gameRunning = false;
        let selectedMode = 'NORMAL';
        let deathCount = 0;
        let stage10JumpCount = 0;

        function startGame(mode) {
            selectedMode = mode;
            startScreen.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            modeDisplay.innerText = selectedMode;
            canvas.style.background = (selectedMode === 'HARD') ? "#0d0202" : (selectedMode === 'EASY' ? "#e0f7fa" : "#87CEEB");
            gameRunning = true;
            deathCount = 0;
            initStage(1);
            requestAnimationFrame(update);
        }

        function initStage(num) {
            const isHard = (selectedMode === 'HARD');
            const gravity = isHard ? 1.25 : 0.9;
            const jumpPower = isHard ? -21.5 : -20.0;
            const friction = isHard ? 0.88 : 1.0; 

            player = { x: 50, y: 500, w: 30, h: 30, vx: 0, vy: 0, speed: isHard ? 9.5 : 8.5, jump: jumpPower, gravity: gravity, friction: friction, onGround: false };
            currentStage = num;
            stageDisplay.innerText = currentStage;
            stage10JumpCount = 0;
            
            if (selectedMode === 'EASY') lifeDisplay.innerText = "RETRY: " + (3 - deathCount);
            else lifeDisplay.innerText = isHard ? "CUSTOM HARD MAP" : "NO MERCY";

            // --- ステージデータ ---
            const normalStages = {
                1: [{x:0,y:550,w:200,h:50,type:'p'}, {x:400,y:450,w:150,h:25,type:'p'}, {x:800,y:350,w:150,h:25,type:'p'}, {x:1100,y:250,w:60,h:20,type:'g'}],
                // ... (中略) ... 
                10:[{x:0,y:550,w:150,h:50,type:'p'}, {x:600,y:300,w:30,h:10,type:'p'}] 
            };

            const hardStages = {
                1: [{x:0,y:550,w:200,h:50,type:'p'}, {x:250,y:520,w:150,h:20,type:'p'}, {x:450,y:480,w:150,h:20,type:'p'}, {x:700,y:400,w:150,h:20,type:'p'}, {x:1000,y:320,w:100,h:20,type:'g'}],
                2: [{x:0,y:550,w:150,h:50,type:'p'}, {x:200,y:450,w:80,h:20,type:'p',fall:true}, {x:400,y:450,w:80,h:20,type:'p',fall:true}, {x:700,y:350,w:200,h:20,type:'p'}, {x:1100,y:250,w:60,h:20,type:'g'}],
                3: [{x:0,y:550,w:100,h:50,type:'p'}, {x:250,y:520,w:30,h:30,type:'t'}, {x:400,y:450,w:150,h:20,type:'p'}, {x:700,y:300,w:40,h:40,type:'t',move:10}, {x:1000,y:200,w:80,h:20,type:'g'}],
                4: [{x:0,y:550,w:150,h:50,type:'p'}, {x:300,y:400,w:300,h:20,type:'p'}, {x:400,y:360,w:40,h:40,type:'t',move:15}, {x:750,y:400,w:300,h:20,type:'p'}, {x:1100,y:300,w:60,h:20,type:'g'}],
                10:[{x:0,y:550,w:150,h:50,type:'p'}, {x:1100,y:50,w:30,h:10,type:'p'}] // 同じく不可能配置
            };

            // HARDなら専用、なければ通常マップ（共通ギミック用）を使用
            const stageSet = isHard ? (hardStages[num] || normalStages[num]) : (normalStages[num] || normalStages[1]);
            objects = stageSet.map(obj => ({ ...obj, falling: false }));
        }

        function die() {
            if (selectedMode === 'EASY') {
                deathCount++;
                if (deathCount >= 3) { deathCount = 0; initStage(1); }
                else initStage(currentStage);
            } else { deathCount = 0; initStage(1); }
        }

        function jump() {
            if (player.onGround) {
                player.vy = player.jump;
                player.onGround = false;
                if (currentStage === 10) stage10JumpCount++;
            }
        }

        function update() {
            if (!gameRunning) return;
            let moveX = 0;
            const w = window.innerWidth, h = window.innerHeight;

            activeInputs.forEach((pos) => {
                if (pos.y < h * 0.45) jump();
                if (pos.x < w * 0.4) moveX = -player.speed;
                else if (pos.x > w * 0.6) moveX = player.speed;
            });

            if (keys['ArrowLeft']) moveX = -player.speed;
            if (keys['ArrowRight']) moveX = player.speed;
            if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) jump();

            if (selectedMode === 'HARD') {
                player.vx = player.vx * player.friction + moveX * (1 - player.friction);
            } else {
                player.vx = moveX;
            }

            player.vy += player.gravity;
            player.x += player.vx;
            checkCollision('x');
            player.y += player.vy;
            player.onGround = false;
            checkCollision('y');

            if (currentStage === 10 && stage10JumpCount >= 3 && player.x < -player.w) {
                alert('HARD MODE CLEAR! あなたは伝説のプレイヤーです。');
                initStage(1);
            }

            objects.forEach(obj => {
                if (obj.hidden) {
                    let d = Math.sqrt(Math.pow(player.x - obj.x, 2) + Math.pow(player.y - obj.y, 2));
                    if (d < 150) obj.hidden = false;
                }
                if (obj.move) { obj.x += obj.move; if (obj.x > 900 || obj.x < 300) obj.move *= -1; }
                if (obj.falling) obj.y += 12;
            });

            if (player.y > canvas.height) die();
            draw();
            requestAnimationFrame(update);
        }

        function checkCollision(axis) {
            objects.forEach(obj => {
                if (obj.hidden) return;
                if (player.x < obj.x + obj.w && player.x + player.w > obj.x &&
                    player.y < obj.y + obj.h && player.y + player.h > obj.y) {
                    if (obj.type === 't') die();
                    if (obj.type === 'g') {
                        deathCount = 0;
                        if (obj.warp) initStage(obj.warp);
                        else if (currentStage >= 10) { alert('CLEAR!'); initStage(1); }
                        else initStage(currentStage + 1);
                    }
                    if (obj.type === 'p') {
                        if (obj.fall) obj.falling = true;
                        if (axis === 'x') {
                            if (player.vx > 0) player.x = obj.x - player.w;
                            else if (player.vx < 0) player.x = obj.x + player.w;
                            player.vx = 0;
                        } else {
                            if (player.vy > 0) { player.y = obj.y - player.h; player.vy = 0; player.onGround = true; }
                            else if (player.vy < 0) { player.y = obj.y + obj.h; player.vy = 0; }
                        }
                    }
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            objects.forEach(obj => {
                if (obj.hidden) return;
                ctx.fillStyle = obj.type === 'p' ? (obj.fall ? '#666' : '#333') : (obj.type === 't' ? '#f00' : '#ff0');
                if (obj.type === 't') {
                    ctx.beginPath(); ctx.moveTo(obj.x, obj.y + obj.h); ctx.lineTo(obj.x + obj.w / 2, obj.y); ctx.lineTo(obj.x + obj.w, obj.y + obj.h); ctx.fill();
                } else { ctx.fillRect(obj.x, obj.y, obj.w, obj.h); }
            });
            ctx.fillStyle = (selectedMode === 'HARD') ? '#ff4444' : (selectedMode === 'EASY' ? '#28a745' : '#07f');
            ctx.fillRect(player.x, player.y, player.w, player.h);

            if (currentStage === 10 && stage10JumpCount >= 3) {
                ctx.fillStyle = "white"; ctx.fillText("<< BACK TO SECRET GOAL", 20, 530);
            }
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('touchstart', e => { if (!gameRunning) return; e.preventDefault(); for (let t of e.changedTouches) activeInputs.set(t.identifier, { x: t.clientX, y: t.clientY }); }, {passive: false});
        window.addEventListener('touchmove', e => { if (!gameRunning) return; for (let t of e.changedTouches) if (activeInputs.has(t.identifier)) activeInputs.set(t.identifier, { x: t.clientX, y: t.clientY }); });
        window.addEventListener('touchend', e => { for (let t of e.changedTouches) activeInputs.delete(t.identifier); });
        window.addEventListener('mousedown', e => { if (!gameRunning || e.button !== 0) return; activeInputs.set('mouse', { x: e.clientX, y: e.clientY }); });
        window.addEventListener('mouseup', () => activeInputs.delete('mouse'));
    </script>
</body>
</html>
